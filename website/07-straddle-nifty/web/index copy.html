<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NIFTY Straddle Amount Viewer</title>

  <style>
    :root {
      --border: #e5e7eb;
      --bg: #ffffff;
      --muted: #6b7280;
      --text: #111827;
      --card: #f9fafb;
      --green: #dcfce7;
      --red: #fee2e2;
      --yellow: #fff9c4;
      --blue: #2563eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background: var(--bg);
    }

    .wrap {
      max-width: 1500px;
      margin: 0 auto;
      padding: 18px;
    }

    .topbar {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .title {
      font-size: 18px;
      font-weight: 800;
    }

    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="number"],
    input[type="text"] {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      min-width: 150px;
      outline: none;
      background: #fff;
    }

    input[type="file"] {
      display: block;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }

    /* ✅ No horizontal scroll */
    .tableWrap {
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
    }

    th,
    td {
      border-bottom: 1px solid var(--border);
      padding: 6px 4px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 11px;
    }

    th {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 2;
      color: var(--muted);
      font-weight: 700;
    }

    /* Strike column */
    th.strikecol,
    td.strikecol {
      text-align: right;
      width: 64px;
    }

    /* BuyDate column */
    th.buycol,
    td.buycol {
      text-align: left;
      width: 42px;
    }

    /* Summary columns */
    th.sumcol,
    td.sumcol {
      width: 72px;
      font-weight: 700;
    }

    /* ✅ Profit/Loss background colors */
    td.profit {
      background: var(--green);
    }

    td.loss {
      background: var(--red);
    }

    /* ✅ Search highlight */
    th.match,
    td.match {
      background: var(--yellow) !important;
      font-weight: 800;
    }

    /* ✅ Buy-day border */
    td.buyday {
      outline: 2px solid var(--blue);
      outline-offset: -2px;
      font-weight: 900;
    }

    tr:hover td {
      background: #fafafa;
    }

    .footer {
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .monthTitle {
      font-weight: 900;
      margin-top: 6px;
      font-size: 14px;
      color: #111827;
    }

    .error {
      color: #b91c1c;
      font-weight: 700;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">Straddle Amount Matrix (Lots × LotSize)</div>

      <div class="controls">
        <div class="card">
          <label>Load CSV</label>
          <input id="fileInput" type="file" accept=".csv" />
          <div class="hint">Upload: straddle_matrix_YYYY_MM.csv</div>
        </div>

        <div class="card">
          <label>Number of lots</label>
          <input id="lots" type="number" value="1" min="0" step="1" />
        </div>

        <div class="card">
          <label>Lot size</label>
          <input id="lotSize" type="number" value="65" min="0" step="1" />
        </div>
      </div>

      <div class="card">
        <label>Export</label>
        <button id="exportBtn" type="button"
          style="padding:8px 12px; border:1px solid var(--border); border-radius:10px; cursor:pointer; background:#fff;">
          Export Table CSV
        </button>
        <div class="hint">Downloads calculated table values</div>
      </div>
    </div>

    <div class="footer" id="status">Load a CSV to view data.</div>
    <div class="monthTitle" id="monthLabel"></div>

    <!-- ✅ Search Number with -/+ buttons -->
    <div style="margin-top:10px;">
      <div class="card" style="padding:10px; display:inline-block;">
        <label>Search Strike (highlight matches)</label>

        <div style="display:flex; gap:8px; align-items:center;">
          <button id="minusBtn" type="button"
            style="padding:8px 12px; border:1px solid var(--border); border-radius:10px; cursor:pointer;">
            -
          </button>

          <input id="searchBox" type="number" value="26150" step="50" style="min-width:180px;" />

          <button id="plusBtn" type="button"
            style="padding:8px 12px; border:1px solid var(--border); border-radius:10px; cursor:pointer;">
            +
          </button>
        </div>

        <div class="hint">Click - / + to move by 50 strikes</div>
      </div>
    </div>

    <div class="tableWrap" style="display:none" id="tableWrap">
      <table id="tbl"></table>
    </div>

    <div class="footer">
      ✅ Amount shown = <b>Premium × LotSize × Lots</b><br />
      ✅ Green/Red is based on LONG straddle P/L vs Buy Day Premium
    </div>
  </div>

  <script>
    function parseCSV(text) {
      const rows = [];
      let i = 0;
      let cur = "";
      let inQuotes = false;
      let row = [];

      while (i < text.length) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"') {
          if (inQuotes && next === '"') {
            cur += '"';
            i += 2;
            continue;
          }
          inQuotes = !inQuotes;
          i++;
          continue;
        }

        if (!inQuotes && ch === ",") {
          row.push(cur);
          cur = "";
          i++;
          continue;
        }

        if (!inQuotes && (ch === "\n" || ch === "\r")) {
          if (ch === "\r" && next === "\n") i++;
          row.push(cur);
          cur = "";
          if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
          row = [];
          i++;
          continue;
        }

        cur += ch;
        i++;
      }

      if (cur.length > 0 || row.length > 0) {
        row.push(cur);
        rows.push(row);
      }

      return rows;
    }

    const fileInput = document.getElementById("fileInput");
    const lotsEl = document.getElementById("lots");
    const lotSizeEl = document.getElementById("lotSize");
    const statusEl = document.getElementById("status");
    const monthLabelEl = document.getElementById("monthLabel");
    const tableWrap = document.getElementById("tableWrap");
    const tbl = document.getElementById("tbl");
    const searchBoxEl = document.getElementById("searchBox");
    const exportBtn = document.getElementById("exportBtn");


    let header = [];
    let dataRows = [];
    let dateCols = [];
    let loadedFileName = "";
    let searchQuery = "";

    function num(val) {
      if (val === null || val === undefined) return NaN;
      const s = String(val).trim();
      if (!s) return NaN;
      const n = Number(s);
      return Number.isFinite(n) ? n : NaN;
    }

    function fmt(x) {
      if (!Number.isFinite(x)) return "";
      return Math.round(x).toLocaleString();
    }

    function dayOnly(dateStr) {
      if (!dateStr) return "";
      const parts = String(dateStr).split("-");
      return parts.length === 3 ? parts[2] : dateStr;
    }

    function formatMonthFromFileName(name) {
      const m = String(name).match(/straddle_matrix_(\d{4})_(\d{2})\.csv/i);
      if (!m) return name;

      const year = m[1];
      const monthNum = parseInt(m[2], 10);
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const mon = months[monthNum - 1] || m[2];
      return "Straddle for " + year + " " + mon;
    }

    function applySearchHighlight() {
      if (!tbl) return;

      tbl.querySelectorAll(".match").forEach(el => el.classList.remove("match"));

      if (!searchQuery) return;

      tbl.querySelectorAll("th, td").forEach(cell => {
        const txt = (cell.textContent || "").toLowerCase();
        if (txt.includes(searchQuery)) cell.classList.add("match");
      });
    }

    function buildTable() {
      if (!header.length) return;

      monthLabelEl.textContent = loadedFileName ? formatMonthFromFileName(loadedFileName) : "";

      const lots = Math.max(0, Math.floor(num(lotsEl.value) || 0));
      const lotSize = Math.max(0, Math.floor(num(lotSizeEl.value) || 0));

      const FIXED_COUNT = 5;
      dateCols = header.slice(FIXED_COUNT);

      const thead = document.createElement("thead");
      const htr = document.createElement("tr");

      // ✅ order: Strike, Buy, dates..., summary
      const thStrike = document.createElement("th");
      thStrike.textContent = "Strike";
      thStrike.classList.add("strikecol");
      htr.appendChild(thStrike);

      const thBuy = document.createElement("th");
      thBuy.textContent = "Buy";
      thBuy.classList.add("buycol");
      htr.appendChild(thBuy);

      dateCols.forEach(d => {
        const th = document.createElement("th");
        th.textContent = dayOnly(d);
        htr.appendChild(th);
      });

      const thMaxLoss = document.createElement("th");
      thMaxLoss.textContent = "Max Loss";
      thMaxLoss.classList.add("sumcol");
      htr.appendChild(thMaxLoss);

      const thMaxProfit = document.createElement("th");
      thMaxProfit.textContent = "Max Profit";
      thMaxProfit.classList.add("sumcol");
      htr.appendChild(thMaxProfit);

      const thPnL = document.createElement("th");
      thPnL.textContent = "Current PnL";
      thPnL.classList.add("sumcol");
      htr.appendChild(thPnL);

      const thGain = document.createElement("th");
      thGain.textContent = "% Gain";
      thGain.classList.add("sumcol");
      htr.appendChild(thGain);

      thead.appendChild(htr);

      const tbody = document.createElement("tbody");

      dataRows.forEach(r => {
        const buyDay = r.buyDate;
        const buyPremiumStr = (r.dates[buyDay] || "").trim();
        const buyPremium = num(buyPremiumStr);

        let premiums = [];
        dateCols.forEach(d => {
          if (d >= buyDay) {
            const pStr = (r.dates[d] || "").trim();
            const p = num(pStr);
            if (Number.isFinite(p)) premiums.push(p);
          }
        });

        const currentPremium = premiums.length ? premiums[premiums.length - 1] : NaN;
        const maxPremium = premiums.length ? Math.max(...premiums) : NaN;
        const minPremium = premiums.length ? Math.min(...premiums) : NaN;

        const investedAmount = (Number.isFinite(buyPremium) ? buyPremium : 0) * lotSize * lots;

        const pnl = (Number.isFinite(currentPremium) && Number.isFinite(buyPremium))
          ? (currentPremium - buyPremium) * lotSize * lots
          : NaN;

        const maxProfit = (Number.isFinite(maxPremium) && Number.isFinite(buyPremium))
          ? (maxPremium - buyPremium) * lotSize * lots
          : NaN;

        const maxLoss = (Number.isFinite(minPremium) && Number.isFinite(buyPremium))
          ? (minPremium - buyPremium) * lotSize * lots
          : NaN;

        const pctGain = (Number.isFinite(pnl) && investedAmount > 0)
          ? (pnl / investedAmount) * 100
          : NaN;

        const tr = document.createElement("tr");

        // Strike
        const tdStrike = document.createElement("td");
        tdStrike.textContent = r.strike || "";
        tdStrike.classList.add("strikecol");
        tr.appendChild(tdStrike);

        // Buy
        const tdBuy = document.createElement("td");
        tdBuy.textContent = dayOnly(r.buyDate);
        tdBuy.classList.add("buycol");
        tr.appendChild(tdBuy);

        // Dates (amount only)
        dateCols.forEach(d => {
          const premStr = (r.dates[d] || "").trim();
          const prem = num(premStr);

          const td = document.createElement("td");

          if (premStr && Number.isFinite(prem) && lotSize > 0 && lots > 0) {
            td.textContent = fmt(prem * lotSize * lots);
          } else {
            td.textContent = "";
          }

          // ✅ Buy day border
          if (d === buyDay) td.classList.add("buyday");

          // ✅ Profit/Loss coloring from next day onward
          if (Number.isFinite(buyPremium) && d > buyDay && Number.isFinite(prem)) {
            if (prem > buyPremium) td.classList.add("profit");
            else if (prem < buyPremium) td.classList.add("loss");
          }

          tr.appendChild(td);
        });

        // Summary columns
        const tdMaxLoss = document.createElement("td");
        tdMaxLoss.textContent = fmt(maxLoss);
        tdMaxLoss.classList.add("sumcol");
        if (Number.isFinite(maxLoss) && maxLoss < 0) tdMaxLoss.classList.add("loss");
        tr.appendChild(tdMaxLoss);

        const tdMaxProfit = document.createElement("td");
        tdMaxProfit.textContent = fmt(maxProfit);
        tdMaxProfit.classList.add("sumcol");
        if (Number.isFinite(maxProfit) && maxProfit > 0) tdMaxProfit.classList.add("profit");
        tr.appendChild(tdMaxProfit);

        const tdPnL = document.createElement("td");
        tdPnL.textContent = fmt(pnl);
        tdPnL.classList.add("sumcol");
        if (Number.isFinite(pnl)) {
          if (pnl > 0) tdPnL.classList.add("profit");
          else if (pnl < 0) tdPnL.classList.add("loss");
        }
        tr.appendChild(tdPnL);

        const tdGain = document.createElement("td");
        tdGain.classList.add("sumcol");
        tdGain.textContent = Number.isFinite(pctGain) ? Math.round(pctGain) + "%" : "";
        if (Number.isFinite(pctGain)) {
          if (pctGain > 0) tdGain.classList.add("profit");
          else if (pctGain < 0) tdGain.classList.add("loss");
        }
        tr.appendChild(tdGain);

        tbody.appendChild(tr);
      });

      tbl.innerHTML = "";
      tbl.appendChild(thead);
      tbl.appendChild(tbody);

      statusEl.textContent = "Loaded " + dataRows.length + " rows | Lots=" + lots + " | LotSize=" + lotSize;
      tableWrap.style.display = "";

      applySearchHighlight();
    }

    function loadCSVText(text) {
      const rows = parseCSV(text);

      if (!rows.length) {
        statusEl.innerHTML = '<span class="error">CSV is empty.</span>';
        return;
      }

      header = rows[0];
      const FIXED_COUNT = 5;

      if (header.length <= FIXED_COUNT) {
        statusEl.innerHTML = '<span class="error">Invalid CSV: date columns not found.</span>';
        return;
      }

      const width = header.length;
      dataRows = [];

      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r || r.length === 0) continue;

        const padded = r.slice(0);
        while (padded.length < width) padded.push("");

        const buyDate = padded[0];
        const strike = padded[2];

        const dates = {};
        for (let c = FIXED_COUNT; c < width; c++) {
          dates[header[c]] = padded[c] || "";
        }

        dataRows.push({ buyDate, strike, dates });
      }

      buildTable();
    }

    fileInput.addEventListener("change", async e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      loadedFileName = file.name;
      statusEl.textContent = "Reading file...";

      const text = await file.text();
      loadCSVText(text);
    });

    lotsEl.addEventListener("input", () => header.length && buildTable());
    lotSizeEl.addEventListener("input", () => header.length && buildTable());

    // ✅ Search live highlight
    searchBoxEl.addEventListener("input", () => {
      searchQuery = (searchBoxEl.value || "").trim().toLowerCase();
      applySearchHighlight();
    });

    const minusBtn = document.getElementById("minusBtn");
    const plusBtn = document.getElementById("plusBtn");

    function setSearchValue(newVal) {
      // Round to nearest 50 and avoid negative values
      const v = Math.max(0, Math.round(newVal / 50) * 50);

      // Update input box UI
      searchBoxEl.value = v;

      // Update searchQuery (string match works because table text is string)
      searchQuery = String(v).trim().toLowerCase();

      // Highlight table
      applySearchHighlight();
    }

    // ✅ Search live highlight (when user types manually)
    searchBoxEl.addEventListener("input", () => {
      const v = Number(searchBoxEl.value || 0);
      setSearchValue(v);
    });

    // ✅ - button reduces by 50
    minusBtn.addEventListener("click", () => {
      const current = Number(searchBoxEl.value || 0);
      setSearchValue(current - 50);
    });

    // ✅ + button increases by 50
    plusBtn.addEventListener("click", () => {
      const current = Number(searchBoxEl.value || 0);
      setSearchValue(current + 50);
    });

    function downloadCSV(filename, rows) {
      // rows = array of array of strings
      const csvText = rows
        .map(r => r.map(v => {
          const s = String(v ?? "");
          // escape commas, quotes, new lines
          if (s.includes('"') || s.includes(",") || s.includes("\n")) {
            return `"${s.replace(/"/g, '""')}"`;
          }
          return s;
        }).join(","))
        .join("\n");

      const blob = new Blob([csvText], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);
    }

    function exportTableToCSV() {
      if (!header.length || !dataRows.length) {
        alert("No table data loaded.");
        return;
      }

      const lots = Math.max(0, Math.floor(num(lotsEl.value) || 0));
      const lotSize = Math.max(0, Math.floor(num(lotSizeEl.value) || 0));

      const FIXED_COUNT = 5;
      const dateColsLocal = header.slice(FIXED_COUNT);

      // ✅ CSV header row (same as table view)
      const out = [];
      out.push([
        "Strike",
        "Buy",
        ...dateColsLocal.map(d => dayOnly(d)),
        "Max Loss",
        "Max Profit",
        "Current PnL",
        "% Gain"
      ]);

      // ✅ CSV rows (same calculations as buildTable)
      dataRows.forEach(r => {
        const buyDay = r.buyDate;
        const buyPremium = num((r.dates[buyDay] || "").trim());

        let premiums = [];
        dateColsLocal.forEach(d => {
          if (d >= buyDay) {
            const p = num((r.dates[d] || "").trim());
            if (Number.isFinite(p)) premiums.push(p);
          }
        });

        const currentPremium = premiums.length ? premiums[premiums.length - 1] : NaN;
        const maxPremium = premiums.length ? Math.max(...premiums) : NaN;
        const minPremium = premiums.length ? Math.min(...premiums) : NaN;

        const investedAmount = (Number.isFinite(buyPremium) ? buyPremium : 0) * lotSize * lots;

        const pnl = (Number.isFinite(currentPremium) && Number.isFinite(buyPremium))
          ? (currentPremium - buyPremium) * lotSize * lots
          : NaN;

        const maxProfit = (Number.isFinite(maxPremium) && Number.isFinite(buyPremium))
          ? (maxPremium - buyPremium) * lotSize * lots
          : NaN;

        const maxLoss = (Number.isFinite(minPremium) && Number.isFinite(buyPremium))
          ? (minPremium - buyPremium) * lotSize * lots
          : NaN;

        const pctGain = (Number.isFinite(pnl) && investedAmount > 0)
          ? (pnl / investedAmount) * 100
          : NaN;

        // ✅ date values = Premium × lotSize × lots (same as UI)
        const dateValues = dateColsLocal.map(d => {
          const prem = num((r.dates[d] || "").trim());
          if (Number.isFinite(prem) && lotSize > 0 && lots > 0) {
            return String(Math.round(prem * lotSize * lots));
          }
          return "";
        });

        out.push([
          r.strike || "",
          dayOnly(r.buyDate),
          ...dateValues,
          Number.isFinite(maxLoss) ? String(Math.round(maxLoss)) : "",
          Number.isFinite(maxProfit) ? String(Math.round(maxProfit)) : "",
          Number.isFinite(pnl) ? String(Math.round(pnl)) : "",
          Number.isFinite(pctGain) ? String(Math.round(pctGain)) + "%" : ""
        ]);
      });

      const baseName = loadedFileName ? loadedFileName.replace(".csv", "") : "straddle_export";
      const finalName = `${baseName}_lots${lots}_size${lotSize}.csv`;

      downloadCSV(finalName, out);
    }

    exportBtn.addEventListener("click", exportTableToCSV);


  </script>
</body>

</html>